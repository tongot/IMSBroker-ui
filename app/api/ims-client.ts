//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    generateToken(command: LoginCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateToken(_response);
        });
    }

    protected processGenerateToken(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    forgotPassword(command: ForgotPasswordCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    resetPassword(command: ResetPasswordCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    createUser(command: CreateUserCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/create-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUser(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUser2(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser2(_response);
        });
    }

    protected processGetUser2(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getSearchUser(query: SearchUserQuery): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/get-searched-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSearchUser(_response);
        });
    }

    protected processGetSearchUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class AddOnsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAddOns(): Promise<DefaultAddOnViewDto[]> {
        let url_ = this.baseUrl + "/api/AddOns";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAddOns(_response);
        });
    }

    protected processGetAddOns(response: Response): Promise<DefaultAddOnViewDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DefaultAddOnViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DefaultAddOnViewDto[]>(null as any);
    }

    addAddOn(newAddOn: AddDefaultAddOnDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/AddOns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newAddOn);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddAddOn(_response);
        });
    }

    protected processAddAddOn(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }
}

export class ContactsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAddressFor(entityType: string, entityId: number): Promise<AddressViewDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/{entityType}/{entityId}/address";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAddressFor(_response);
        });
    }

    protected processGetAddressFor(response: Response): Promise<AddressViewDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddressViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddressViewDto[]>(null as any);
    }

    addAddressFor(entityType: string, entityId: number, address: AddressViewDto): Promise<ApiResponseOfAddressViewDto> {
        let url_ = this.baseUrl + "/api/Contacts/{entityType}/{entityId}/address";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(address);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddAddressFor(_response);
        });
    }

    protected processAddAddressFor(response: Response): Promise<ApiResponseOfAddressViewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfAddressViewDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfAddressViewDto>(null as any);
    }

    getContactFor(entityType: string, entityId: number): Promise<ContactViewDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/{entityType}/{entityId}/contact";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactFor(_response);
        });
    }

    protected processGetContactFor(response: Response): Promise<ContactViewDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactViewDto[]>(null as any);
    }

    addContactFor(entityType: string, entityId: number, contact: ContactViewDto): Promise<ApiResponseOfContactViewDto> {
        let url_ = this.baseUrl + "/api/Contacts/{entityType}/{entityId}/contact";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contact);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddContactFor(_response);
        });
    }

    protected processAddContactFor(response: Response): Promise<ApiResponseOfContactViewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfContactViewDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfContactViewDto>(null as any);
    }

    updateContactFor(entityType: string, entityId: number, contact: ContactViewDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Contacts/{entityType}/{entityId}/contact-update";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contact);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContactFor(_response);
        });
    }

    protected processUpdateContactFor(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    updateAddressFor(entityType: string, entityId: number, address: AddressViewDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Contacts/{entityType}/{entityId}/address-update";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(address);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAddressFor(_response);
        });
    }

    protected processUpdateAddressFor(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    deleteAddressFor(id: number): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Contacts/{id}/address-delete";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAddressFor(_response);
        });
    }

    protected processDeleteAddressFor(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    deleteContactFor(id: number): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Contacts/{id}/contact-delete";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContactFor(_response);
        });
    }

    protected processDeleteContactFor(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }
}

export class CoverStructureClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createCoverStructure(cover: CoverStructureDto): Promise<ApiResponseOfCoverStructureDto> {
        let url_ = this.baseUrl + "/api/CoverStructure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cover);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCoverStructure(_response);
        });
    }

    protected processCreateCoverStructure(response: Response): Promise<ApiResponseOfCoverStructureDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCoverStructureDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfCoverStructureDto>(null as any);
    }

    getCoverStructures(underwriterInsuranceId: number): Promise<CoverStructureDto[]> {
        let url_ = this.baseUrl + "/api/CoverStructure/{underwriterInsuranceId}";
        if (underwriterInsuranceId === undefined || underwriterInsuranceId === null)
            throw new Error("The parameter 'underwriterInsuranceId' must be defined.");
        url_ = url_.replace("{underwriterInsuranceId}", encodeURIComponent("" + underwriterInsuranceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoverStructures(_response);
        });
    }

    protected processGetCoverStructures(response: Response): Promise<CoverStructureDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CoverStructureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoverStructureDto[]>(null as any);
    }

    updateCoverStructure(updatedCover: CoverStructureDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/CoverStructure/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedCover);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoverStructure(_response);
        });
    }

    protected processUpdateCoverStructure(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    createCoverStructureField(field: CoverStructureFieldDto): Promise<ApiResponseOfCoverStructureFieldDto> {
        let url_ = this.baseUrl + "/api/CoverStructure/field";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(field);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCoverStructureField(_response);
        });
    }

    protected processCreateCoverStructureField(response: Response): Promise<ApiResponseOfCoverStructureFieldDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCoverStructureFieldDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfCoverStructureFieldDto>(null as any);
    }

    getCoverStructureFields(coverStructureId: number): Promise<CoverStructureFieldDto[]> {
        let url_ = this.baseUrl + "/api/CoverStructure/field/{coverStructureId}";
        if (coverStructureId === undefined || coverStructureId === null)
            throw new Error("The parameter 'coverStructureId' must be defined.");
        url_ = url_.replace("{coverStructureId}", encodeURIComponent("" + coverStructureId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoverStructureFields(_response);
        });
    }

    protected processGetCoverStructureFields(response: Response): Promise<CoverStructureFieldDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CoverStructureFieldDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoverStructureFieldDto[]>(null as any);
    }

    updateCoverStructureField(updatedField: CoverStructureFieldDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/CoverStructure/field/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedField);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoverStructureField(_response);
        });
    }

    protected processUpdateCoverStructureField(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    getCoverStructureFieldRules(fieldId: number): Promise<CoverStructureFieldRuleDto[]> {
        let url_ = this.baseUrl + "/api/CoverStructure/field/rules/{fieldId}";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoverStructureFieldRules(_response);
        });
    }

    protected processGetCoverStructureFieldRules(response: Response): Promise<CoverStructureFieldRuleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CoverStructureFieldRuleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoverStructureFieldRuleDto[]>(null as any);
    }

    createCoverStructureFieldRule(rule: CoverStructureFieldRuleDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/CoverStructure/field/rules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rule);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCoverStructureFieldRule(_response);
        });
    }

    protected processCreateCoverStructureFieldRule(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    updateCoverStructureFieldRule(updatedRule: CoverStructureFieldRuleDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/CoverStructure/field/rules/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedRule);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoverStructureFieldRule(_response);
        });
    }

    protected processUpdateCoverStructureFieldRule(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    createAddOnOverrideRate(overrideRate: CreateAddOnCustomeRateCommand): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/CoverStructure/addon-override/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(overrideRate);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAddOnOverrideRate(_response);
        });
    }

    protected processCreateAddOnOverrideRate(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    getCoverStructureAddOns(coverId: number): Promise<GetCoverStructureAddOnDto[]> {
        let url_ = this.baseUrl + "/api/CoverStructure/cover-addons/{coverId}";
        if (coverId === undefined || coverId === null)
            throw new Error("The parameter 'coverId' must be defined.");
        url_ = url_.replace("{coverId}", encodeURIComponent("" + coverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoverStructureAddOns(_response);
        });
    }

    protected processGetCoverStructureAddOns(response: Response): Promise<GetCoverStructureAddOnDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCoverStructureAddOnDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetCoverStructureAddOnDto[]>(null as any);
    }
}

export class LookupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getInsuranceMainTypes(): Promise<InsuranceMainType[]> {
        let url_ = this.baseUrl + "/api/Lookup/ins-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInsuranceMainTypes(_response);
        });
    }

    protected processGetInsuranceMainTypes(response: Response): Promise<InsuranceMainType[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InsuranceMainType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InsuranceMainType[]>(null as any);
    }

    getLookUpFor(types: string): Promise<LookupDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/{types}";
        if (types === undefined || types === null)
            throw new Error("The parameter 'types' must be defined.");
        url_ = url_.replace("{types}", encodeURIComponent("" + types));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLookUpFor(_response);
        });
    }

    protected processGetLookUpFor(response: Response): Promise<LookupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupDto[]>(null as any);
    }

    addLookup(newLookup: AddLookupDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Lookup/new-lookup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newLookup);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLookup(_response);
        });
    }

    protected processAddLookup(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    addLookupType(newLookupType: AddLookupTypeDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Lookup/new-lookup-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newLookupType);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLookupType(_response);
        });
    }

    protected processAddLookupType(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    getLookUpCategories(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Lookup/categories-names";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLookUpCategories(_response);
        });
    }

    protected processGetLookUpCategories(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getLookUpTypes(): Promise<AddLookupTypeDto[]> {
        let url_ = this.baseUrl + "/api/Lookup/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLookUpTypes(_response);
        });
    }

    protected processGetLookUpTypes(response: Response): Promise<AddLookupTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddLookupTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddLookupTypeDto[]>(null as any);
    }
}

export class PeopleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    addPerson(person: AddPersonDto): Promise<ApiResponseOfAddPersonDto> {
        let url_ = this.baseUrl + "/api/People";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(person);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddPerson(_response);
        });
    }

    protected processAddPerson(response: Response): Promise<ApiResponseOfAddPersonDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfAddPersonDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfAddPersonDto>(null as any);
    }

    getPeople(): Promise<GetPersonDto[]> {
        let url_ = this.baseUrl + "/api/People";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPeople(_response);
        });
    }

    protected processGetPeople(response: Response): Promise<GetPersonDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPersonDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetPersonDto[]>(null as any);
    }

    searchPeople(query: SearchPeopleQuery): Promise<GetPersonDto[]> {
        let url_ = this.baseUrl + "/api/People/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPeople(_response);
        });
    }

    protected processSearchPeople(response: Response): Promise<GetPersonDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPersonDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetPersonDto[]>(null as any);
    }
}

export class PolicyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getQuote(quote: GetQuotationChoiceDto): Promise<ApiResponseOfListOfQuotationViewDto> {
        let url_ = this.baseUrl + "/api/Policy/GetQuote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(quote);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuote(_response);
        });
    }

    protected processGetQuote(response: Response): Promise<ApiResponseOfListOfQuotationViewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfListOfQuotationViewDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfListOfQuotationViewDto>(null as any);
    }
}

export class QuotationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getQuotations(searchString: string | null | undefined): Promise<QuotationListDto[]> {
        let url_ = this.baseUrl + "/api/Quotation?";
        if (searchString !== undefined && searchString !== null)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuotations(_response);
        });
    }

    protected processGetQuotations(response: Response): Promise<QuotationListDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuotationListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QuotationListDto[]>(null as any);
    }

    getQuoteFields(insuranceTypeId: number): Promise<FieldsViewDto> {
        let url_ = this.baseUrl + "/api/Quotation/GetQuoteFields/{insuranceTypeId}";
        if (insuranceTypeId === undefined || insuranceTypeId === null)
            throw new Error("The parameter 'insuranceTypeId' must be defined.");
        url_ = url_.replace("{insuranceTypeId}", encodeURIComponent("" + insuranceTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuoteFields(_response);
        });
    }

    protected processGetQuoteFields(response: Response): Promise<FieldsViewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldsViewDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldsViewDto>(null as any);
    }

    getAddOnTypes(insuranceTypeId: number, coverId: number | null | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Quotation/add-ons/{insuranceTypeId}?";
        if (insuranceTypeId === undefined || insuranceTypeId === null)
            throw new Error("The parameter 'insuranceTypeId' must be defined.");
        url_ = url_.replace("{insuranceTypeId}", encodeURIComponent("" + insuranceTypeId));
        if (coverId !== undefined && coverId !== null)
            url_ += "coverId=" + encodeURIComponent("" + coverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAddOnTypes(_response);
        });
    }

    protected processGetAddOnTypes(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    createQuote(command: SaveQuotationCommand): Promise<ApiResponseOfCreateQuotationRespDto> {
        let url_ = this.baseUrl + "/api/Quotation/create-quotation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateQuote(_response);
        });
    }

    protected processCreateQuote(response: Response): Promise<ApiResponseOfCreateQuotationRespDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCreateQuotationRespDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfCreateQuotationRespDto>(null as any);
    }

    overrideRule(command: OverrideFieldRuleCommand): Promise<ApiResponseOfCoverStructureFieldRuleDto> {
        let url_ = this.baseUrl + "/api/Quotation/override-rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOverrideRule(_response);
        });
    }

    protected processOverrideRule(response: Response): Promise<ApiResponseOfCoverStructureFieldRuleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfCoverStructureFieldRuleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfCoverStructureFieldRuleDto>(null as any);
    }

    getQuotationById(id: number): Promise<GetQuotationDto> {
        let url_ = this.baseUrl + "/api/Quotation/get-quotation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetQuotationById(_response);
        });
    }

    protected processGetQuotationById(response: Response): Promise<GetQuotationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQuotationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetQuotationDto>(null as any);
    }
}

export class StateMachineClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    addState(newState: AddStateDto): Promise<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/StateMachine";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newState);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddState(_response);
        });
    }

    protected processAddState(response: Response): Promise<ApiResponseOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfBoolean>(null as any);
    }

    addStateAll(coverStructureId: number): Promise<GetStateDto[]> {
        let url_ = this.baseUrl + "/api/StateMachine/CoverStructureState/{coverStructureId}";
        if (coverStructureId === undefined || coverStructureId === null)
            throw new Error("The parameter 'coverStructureId' must be defined.");
        url_ = url_.replace("{coverStructureId}", encodeURIComponent("" + coverStructureId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddStateAll(_response);
        });
    }

    protected processAddStateAll(response: Response): Promise<GetStateDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetStateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetStateDto[]>(null as any);
    }

    updateState(updatedState: AddStateDto): Promise<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/StateMachine/CoverStructureStateUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedState);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateState(_response);
        });
    }

    protected processUpdateState(response: Response): Promise<ApiResponseOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfBoolean>(null as any);
    }

    deleteState(stateId: number): Promise<ApiResponseOfBoolean> {
        let url_ = this.baseUrl + "/api/StateMachine/CoverStructureStateDelete/{stateId}";
        if (stateId === undefined || stateId === null)
            throw new Error("The parameter 'stateId' must be defined.");
        url_ = url_.replace("{stateId}", encodeURIComponent("" + stateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteState(_response);
        });
    }

    protected processDeleteState(response: Response): Promise<ApiResponseOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfBoolean>(null as any);
    }
}

export class TemplateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getDefaultFields(insuranceTypeId: number): Promise<AddInuranceDefaultFieldDto[]> {
        let url_ = this.baseUrl + "/api/Template/{insuranceTypeId}";
        if (insuranceTypeId === undefined || insuranceTypeId === null)
            throw new Error("The parameter 'insuranceTypeId' must be defined.");
        url_ = url_.replace("{insuranceTypeId}", encodeURIComponent("" + insuranceTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefaultFields(_response);
        });
    }

    protected processGetDefaultFields(response: Response): Promise<AddInuranceDefaultFieldDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddInuranceDefaultFieldDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddInuranceDefaultFieldDto[]>(null as any);
    }

    createDefaultFields(newField: AddInuranceDefaultFieldDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Template/field";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newField);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDefaultFields(_response);
        });
    }

    protected processCreateDefaultFields(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }
}

export class UnderwriterClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    createUnderwriter(underwriter: UnderwriterViewDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Underwriter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(underwriter);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUnderwriter(_response);
        });
    }

    protected processCreateUnderwriter(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUnderwriters(): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Underwriter";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnderwriters(_response);
        });
    }

    protected processGetUnderwriters(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    updateUnderwriter(underwriter: UnderwriterViewDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Underwriter/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(underwriter);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUnderwriter(_response);
        });
    }

    protected processUpdateUnderwriter(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }

    getUnderwriterById(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Underwriter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnderwriterById(_response);
        });
    }

    protected processGetUnderwriterById(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUnderwritersIns(underwriterId: number): Promise<ApiResponseOfListOfUnderwriterInsViewDto> {
        let url_ = this.baseUrl + "/api/Underwriter/Underwriter-ins/{underwriterId}";
        if (underwriterId === undefined || underwriterId === null)
            throw new Error("The parameter 'underwriterId' must be defined.");
        url_ = url_.replace("{underwriterId}", encodeURIComponent("" + underwriterId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnderwritersIns(_response);
        });
    }

    protected processGetUnderwritersIns(response: Response): Promise<ApiResponseOfListOfUnderwriterInsViewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfListOfUnderwriterInsViewDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfListOfUnderwriterInsViewDto>(null as any);
    }

    addUnderwritersIns(newIns: AddUnderwriterInsDto): Promise<ApiResponseOfUnderwriterInsViewDto> {
        let url_ = this.baseUrl + "/api/Underwriter/Underwriter-ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newIns);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddUnderwritersIns(_response);
        });
    }

    protected processAddUnderwritersIns(response: Response): Promise<ApiResponseOfUnderwriterInsViewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfUnderwriterInsViewDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfUnderwriterInsViewDto>(null as any);
    }

    updateUnderwritersIns(updatedIns: AddUnderwriterInsDto): Promise<ApiResponseOfString> {
        let url_ = this.baseUrl + "/api/Underwriter/Underwriter-ins/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedIns);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUnderwritersIns(_response);
        });
    }

    protected processUpdateUnderwritersIns(response: Response): Promise<ApiResponseOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResponseOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResponseOfString>(null as any);
    }
}

export class LoginCommand implements ILoginCommand {
    username?: string;
    password?: string;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginCommand {
    username?: string;
    password?: string;
}

export class ForgotPasswordCommand implements IForgotPasswordCommand {
    email?: string;

    constructor(data?: IForgotPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordCommand {
    email?: string;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email?: string;
    token?: string;
    newPassword?: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    email?: string;
    token?: string;
    newPassword?: string;
}

export class CreateUserCommand implements ICreateUserCommand {
    userName?: string | undefined;
    password?: string | undefined;
    organisationId?: number;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.organisationId = _data["organisationId"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["organisationId"] = this.organisationId;
        return data;
    }
}

export interface ICreateUserCommand {
    userName?: string | undefined;
    password?: string | undefined;
    organisationId?: number;
}

export class SearchUserQuery implements ISearchUserQuery {
    searchUserName?: string;
    excludeList?: string[];

    constructor(data?: ISearchUserQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchUserName = _data["searchUserName"];
            if (Array.isArray(_data["excludeList"])) {
                this.excludeList = [] as any;
                for (let item of _data["excludeList"])
                    this.excludeList!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchUserQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchUserQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchUserName"] = this.searchUserName;
        if (Array.isArray(this.excludeList)) {
            data["excludeList"] = [];
            for (let item of this.excludeList)
                data["excludeList"].push(item);
        }
        return data;
    }
}

export interface ISearchUserQuery {
    searchUserName?: string;
    excludeList?: string[];
}

export class DefaultAddOnViewDto implements IDefaultAddOnViewDto {
    id?: number;
    rate?: number;
    name?: string;
    insuranceMainTypeId?: number;
    description?: string;
    insuranceTypeName?: string;

    constructor(data?: IDefaultAddOnViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rate = _data["rate"];
            this.name = _data["name"];
            this.insuranceMainTypeId = _data["insuranceMainTypeId"];
            this.description = _data["description"];
            this.insuranceTypeName = _data["insuranceTypeName"];
        }
    }

    static fromJS(data: any): DefaultAddOnViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultAddOnViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rate"] = this.rate;
        data["name"] = this.name;
        data["insuranceMainTypeId"] = this.insuranceMainTypeId;
        data["description"] = this.description;
        data["insuranceTypeName"] = this.insuranceTypeName;
        return data;
    }
}

export interface IDefaultAddOnViewDto {
    id?: number;
    rate?: number;
    name?: string;
    insuranceMainTypeId?: number;
    description?: string;
    insuranceTypeName?: string;
}

export class ApiResponseOfString implements IApiResponseOfString {
    data?: string | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfString {
    data?: string | undefined;
    message?: string;
    success?: boolean;
}

export class AddDefaultAddOnDto implements IAddDefaultAddOnDto {
    id?: number;
    rate?: number;
    name?: string;
    insuranceMainTypeId?: number;
    description?: string;

    constructor(data?: IAddDefaultAddOnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rate = _data["rate"];
            this.name = _data["name"];
            this.insuranceMainTypeId = _data["insuranceMainTypeId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AddDefaultAddOnDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddDefaultAddOnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rate"] = this.rate;
        data["name"] = this.name;
        data["insuranceMainTypeId"] = this.insuranceMainTypeId;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddDefaultAddOnDto {
    id?: number;
    rate?: number;
    name?: string;
    insuranceMainTypeId?: number;
    description?: string;
}

export class AddressViewDto implements IAddressViewDto {
    id?: number;
    city?: string;
    street?: string;
    postalCode?: string;
    country?: string;
    addressType?: AddressType;

    constructor(data?: IAddressViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.city = _data["city"];
            this.street = _data["street"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
            this.addressType = _data["addressType"];
        }
    }

    static fromJS(data: any): AddressViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["city"] = this.city;
        data["street"] = this.street;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        data["addressType"] = this.addressType;
        return data;
    }
}

export interface IAddressViewDto {
    id?: number;
    city?: string;
    street?: string;
    postalCode?: string;
    country?: string;
    addressType?: AddressType;
}

export enum AddressType {
    PostalAddress = 0,
    PhysicalAddress = 1,
}

export class ContactViewDto implements IContactViewDto {
    id?: number;
    mobileNumber?: string;
    tel?: string;
    email?: string;

    constructor(data?: IContactViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mobileNumber = _data["mobileNumber"];
            this.tel = _data["tel"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ContactViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mobileNumber"] = this.mobileNumber;
        data["tel"] = this.tel;
        data["email"] = this.email;
        return data;
    }
}

export interface IContactViewDto {
    id?: number;
    mobileNumber?: string;
    tel?: string;
    email?: string;
}

export class ApiResponseOfContactViewDto implements IApiResponseOfContactViewDto {
    data?: ContactViewDto | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfContactViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ContactViewDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfContactViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfContactViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfContactViewDto {
    data?: ContactViewDto | undefined;
    message?: string;
    success?: boolean;
}

export class ApiResponseOfAddressViewDto implements IApiResponseOfAddressViewDto {
    data?: AddressViewDto | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfAddressViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AddressViewDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfAddressViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfAddressViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfAddressViewDto {
    data?: AddressViewDto | undefined;
    message?: string;
    success?: boolean;
}

export class ApiResponseOfCoverStructureDto implements IApiResponseOfCoverStructureDto {
    data?: CoverStructureDto | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfCoverStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CoverStructureDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfCoverStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfCoverStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfCoverStructureDto {
    data?: CoverStructureDto | undefined;
    message?: string;
    success?: boolean;
}

export class CoverStructureDto implements ICoverStructureDto {
    id?: number;
    name?: string;
    rate?: number;
    description?: string;
    hasDependencies?: boolean;
    hasBeneficiary?: boolean;
    underwriterId?: number;
    underwriterInsuranceId?: number;

    constructor(data?: ICoverStructureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rate = _data["rate"];
            this.description = _data["description"];
            this.hasDependencies = _data["hasDependencies"];
            this.hasBeneficiary = _data["hasBeneficiary"];
            this.underwriterId = _data["underwriterId"];
            this.underwriterInsuranceId = _data["underwriterInsuranceId"];
        }
    }

    static fromJS(data: any): CoverStructureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoverStructureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["description"] = this.description;
        data["hasDependencies"] = this.hasDependencies;
        data["hasBeneficiary"] = this.hasBeneficiary;
        data["underwriterId"] = this.underwriterId;
        data["underwriterInsuranceId"] = this.underwriterInsuranceId;
        return data;
    }
}

export interface ICoverStructureDto {
    id?: number;
    name?: string;
    rate?: number;
    description?: string;
    hasDependencies?: boolean;
    hasBeneficiary?: boolean;
    underwriterId?: number;
    underwriterInsuranceId?: number;
}

export class ApiResponseOfCoverStructureFieldDto implements IApiResponseOfCoverStructureFieldDto {
    data?: CoverStructureFieldDto | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfCoverStructureFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CoverStructureFieldDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfCoverStructureFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfCoverStructureFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfCoverStructureFieldDto {
    data?: CoverStructureFieldDto | undefined;
    message?: string;
    success?: boolean;
}

export class CoverStructureFieldDto implements ICoverStructureFieldDto {
    id?: number;
    name?: string;
    value?: string;
    type?: string;
    hint?: string;
    isRequired?: boolean;
    quotationFieldId?: number;
    isActive?: boolean;
    defaultValue?: string;
    coverStructureId?: number;
    subHeading?: string;
    validationPattern?: string | undefined;
    validationObject?: string | undefined;
    order?: number;
    premiumCalcRule?: CoverStructureFieldRuleDto[];

    constructor(data?: ICoverStructureFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.hint = _data["hint"];
            this.isRequired = _data["isRequired"];
            this.quotationFieldId = _data["quotationFieldId"];
            this.isActive = _data["isActive"];
            this.defaultValue = _data["defaultValue"];
            this.coverStructureId = _data["coverStructureId"];
            this.subHeading = _data["subHeading"];
            this.validationPattern = _data["validationPattern"];
            this.validationObject = _data["validationObject"];
            this.order = _data["order"];
            if (Array.isArray(_data["premiumCalcRule"])) {
                this.premiumCalcRule = [] as any;
                for (let item of _data["premiumCalcRule"])
                    this.premiumCalcRule!.push(CoverStructureFieldRuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CoverStructureFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoverStructureFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["type"] = this.type;
        data["hint"] = this.hint;
        data["isRequired"] = this.isRequired;
        data["quotationFieldId"] = this.quotationFieldId;
        data["isActive"] = this.isActive;
        data["defaultValue"] = this.defaultValue;
        data["coverStructureId"] = this.coverStructureId;
        data["subHeading"] = this.subHeading;
        data["validationPattern"] = this.validationPattern;
        data["validationObject"] = this.validationObject;
        data["order"] = this.order;
        if (Array.isArray(this.premiumCalcRule)) {
            data["premiumCalcRule"] = [];
            for (let item of this.premiumCalcRule)
                data["premiumCalcRule"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ICoverStructureFieldDto {
    id?: number;
    name?: string;
    value?: string;
    type?: string;
    hint?: string;
    isRequired?: boolean;
    quotationFieldId?: number;
    isActive?: boolean;
    defaultValue?: string;
    coverStructureId?: number;
    subHeading?: string;
    validationPattern?: string | undefined;
    validationObject?: string | undefined;
    order?: number;
    premiumCalcRule?: CoverStructureFieldRuleDto[];
}

export class CoverStructureFieldRuleDto implements ICoverStructureFieldRuleDto {
    id?: number;
    coverStructureFieldId?: number;
    fieldName?: string;
    operator?: string;
    value?: string;
    adjuster?: string;
    adjustmentType?: string;
    isActive?: boolean;
    isOverride?: boolean;
    overrideRuleId?: number;

    constructor(data?: ICoverStructureFieldRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coverStructureFieldId = _data["coverStructureFieldId"];
            this.fieldName = _data["fieldName"];
            this.operator = _data["operator"];
            this.value = _data["value"];
            this.adjuster = _data["adjuster"];
            this.adjustmentType = _data["adjustmentType"];
            this.isActive = _data["isActive"];
            this.isOverride = _data["isOverride"];
            this.overrideRuleId = _data["overrideRuleId"];
        }
    }

    static fromJS(data: any): CoverStructureFieldRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoverStructureFieldRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coverStructureFieldId"] = this.coverStructureFieldId;
        data["fieldName"] = this.fieldName;
        data["operator"] = this.operator;
        data["value"] = this.value;
        data["adjuster"] = this.adjuster;
        data["adjustmentType"] = this.adjustmentType;
        data["isActive"] = this.isActive;
        data["isOverride"] = this.isOverride;
        data["overrideRuleId"] = this.overrideRuleId;
        return data;
    }
}

export interface ICoverStructureFieldRuleDto {
    id?: number;
    coverStructureFieldId?: number;
    fieldName?: string;
    operator?: string;
    value?: string;
    adjuster?: string;
    adjustmentType?: string;
    isActive?: boolean;
    isOverride?: boolean;
    overrideRuleId?: number;
}

export class CreateAddOnCustomeRateCommand implements ICreateAddOnCustomeRateCommand {
    addOnId?: number;
    coverStructureId?: number;
    rate?: number;

    constructor(data?: ICreateAddOnCustomeRateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addOnId = _data["addOnId"];
            this.coverStructureId = _data["coverStructureId"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): CreateAddOnCustomeRateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAddOnCustomeRateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addOnId"] = this.addOnId;
        data["coverStructureId"] = this.coverStructureId;
        data["rate"] = this.rate;
        return data;
    }
}

export interface ICreateAddOnCustomeRateCommand {
    addOnId?: number;
    coverStructureId?: number;
    rate?: number;
}

export class GetCoverStructureAddOnDto implements IGetCoverStructureAddOnDto {
    id?: number;
    defaultAddOnsId?: number;
    coverStructureId?: number;
    name?: string;
    rate?: number;
    defaultRate?: number;

    constructor(data?: IGetCoverStructureAddOnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.defaultAddOnsId = _data["defaultAddOnsId"];
            this.coverStructureId = _data["coverStructureId"];
            this.name = _data["name"];
            this.rate = _data["rate"];
            this.defaultRate = _data["defaultRate"];
        }
    }

    static fromJS(data: any): GetCoverStructureAddOnDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCoverStructureAddOnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["defaultAddOnsId"] = this.defaultAddOnsId;
        data["coverStructureId"] = this.coverStructureId;
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["defaultRate"] = this.defaultRate;
        return data;
    }
}

export interface IGetCoverStructureAddOnDto {
    id?: number;
    defaultAddOnsId?: number;
    coverStructureId?: number;
    name?: string;
    rate?: number;
    defaultRate?: number;
}

export class InsuranceMainType implements IInsuranceMainType {
    id?: number;
    name?: string;
    hasExcess?: boolean;
    underwriters?: UnderwriterInsurance[];

    constructor(data?: IInsuranceMainType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.hasExcess = _data["hasExcess"];
            if (Array.isArray(_data["underwriters"])) {
                this.underwriters = [] as any;
                for (let item of _data["underwriters"])
                    this.underwriters!.push(UnderwriterInsurance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsuranceMainType {
        data = typeof data === 'object' ? data : {};
        let result = new InsuranceMainType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["hasExcess"] = this.hasExcess;
        if (Array.isArray(this.underwriters)) {
            data["underwriters"] = [];
            for (let item of this.underwriters)
                data["underwriters"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IInsuranceMainType {
    id?: number;
    name?: string;
    hasExcess?: boolean;
    underwriters?: UnderwriterInsurance[];
}

export abstract class ISoftDelete implements IISoftDelete {
    isDeleted?: boolean;

    constructor(data?: IISoftDelete) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): ISoftDelete {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ISoftDelete' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IISoftDelete {
    isDeleted?: boolean;
}

export class UnderwriterInsurance extends ISoftDelete implements IUnderwriterInsurance {
    id?: number;
    totalCommission?: number;
    commission?: number;
    vat?: number;
    underwriterId?: number;
    insuranceMainTypeId?: number;
    underwriter?: Underwriter;
    insuranceMainType?: InsuranceMainType;

    constructor(data?: IUnderwriterInsurance) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.totalCommission = _data["totalCommission"];
            this.commission = _data["commission"];
            this.vat = _data["vat"];
            this.underwriterId = _data["underwriterId"];
            this.insuranceMainTypeId = _data["insuranceMainTypeId"];
            this.underwriter = _data["underwriter"] ? Underwriter.fromJS(_data["underwriter"]) : <any>undefined;
            this.insuranceMainType = _data["insuranceMainType"] ? InsuranceMainType.fromJS(_data["insuranceMainType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UnderwriterInsurance {
        data = typeof data === 'object' ? data : {};
        let result = new UnderwriterInsurance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalCommission"] = this.totalCommission;
        data["commission"] = this.commission;
        data["vat"] = this.vat;
        data["underwriterId"] = this.underwriterId;
        data["insuranceMainTypeId"] = this.insuranceMainTypeId;
        data["underwriter"] = this.underwriter ? this.underwriter.toJSON() : <any>undefined;
        data["insuranceMainType"] = this.insuranceMainType ? this.insuranceMainType.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUnderwriterInsurance extends IISoftDelete {
    id?: number;
    totalCommission?: number;
    commission?: number;
    vat?: number;
    underwriterId?: number;
    insuranceMainTypeId?: number;
    underwriter?: Underwriter;
    insuranceMainType?: InsuranceMainType;
}

export abstract class TrackModify implements ITrackModify {
    modifiedBy?: string;
    maybeModifiedOn?: Date;
    createdBy?: string | undefined;
    action?: string;
    isDeleted?: boolean;

    constructor(data?: ITrackModify) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modifiedBy = _data["modifiedBy"];
            this.maybeModifiedOn = _data["maybeModifiedOn"] ? new Date(_data["maybeModifiedOn"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.action = _data["action"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): TrackModify {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'TrackModify' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modifiedBy"] = this.modifiedBy;
        data["maybeModifiedOn"] = this.maybeModifiedOn ? this.maybeModifiedOn.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["action"] = this.action;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface ITrackModify {
    modifiedBy?: string;
    maybeModifiedOn?: Date;
    createdBy?: string | undefined;
    action?: string;
    isDeleted?: boolean;
}

export class Underwriter extends TrackModify implements IUnderwriter {
    id?: number;
    name?: string;
    status?: UnderwriterStatus;
    availableInsurance?: UnderwriterInsurance[];
    contact?: Contact[];
    address?: Address[];

    constructor(data?: IUnderwriter) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.status = _data["status"];
            if (Array.isArray(_data["availableInsurance"])) {
                this.availableInsurance = [] as any;
                for (let item of _data["availableInsurance"])
                    this.availableInsurance!.push(UnderwriterInsurance.fromJS(item));
            }
            if (Array.isArray(_data["contact"])) {
                this.contact = [] as any;
                for (let item of _data["contact"])
                    this.contact!.push(Contact.fromJS(item));
            }
            if (Array.isArray(_data["address"])) {
                this.address = [] as any;
                for (let item of _data["address"])
                    this.address!.push(Address.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Underwriter {
        data = typeof data === 'object' ? data : {};
        let result = new Underwriter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["status"] = this.status;
        if (Array.isArray(this.availableInsurance)) {
            data["availableInsurance"] = [];
            for (let item of this.availableInsurance)
                data["availableInsurance"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.contact)) {
            data["contact"] = [];
            for (let item of this.contact)
                data["contact"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item ? item.toJSON() : <any>undefined);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUnderwriter extends ITrackModify {
    id?: number;
    name?: string;
    status?: UnderwriterStatus;
    availableInsurance?: UnderwriterInsurance[];
    contact?: Contact[];
    address?: Address[];
}

export enum UnderwriterStatus {
    Active = 0,
    InActive = 1,
}

export class Contact extends TrackModify implements IContact {
    id?: number;
    mobileNumber?: string;
    tel?: string;
    email?: string;
    entityKey?: number;
    entityType?: string;

    constructor(data?: IContact) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.mobileNumber = _data["mobileNumber"];
            this.tel = _data["tel"];
            this.email = _data["email"];
            this.entityKey = _data["entityKey"];
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mobileNumber"] = this.mobileNumber;
        data["tel"] = this.tel;
        data["email"] = this.email;
        data["entityKey"] = this.entityKey;
        data["entityType"] = this.entityType;
        super.toJSON(data);
        return data;
    }
}

export interface IContact extends ITrackModify {
    id?: number;
    mobileNumber?: string;
    tel?: string;
    email?: string;
    entityKey?: number;
    entityType?: string;
}

export class Address extends TrackModify implements IAddress {
    id?: number;
    city?: string;
    street?: string;
    postalCode?: string;
    country?: string;
    addressType?: AddressType;
    entityKey?: number;
    entityType?: string;

    constructor(data?: IAddress) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.city = _data["city"];
            this.street = _data["street"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
            this.addressType = _data["addressType"];
            this.entityKey = _data["entityKey"];
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["city"] = this.city;
        data["street"] = this.street;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        data["addressType"] = this.addressType;
        data["entityKey"] = this.entityKey;
        data["entityType"] = this.entityType;
        super.toJSON(data);
        return data;
    }
}

export interface IAddress extends ITrackModify {
    id?: number;
    city?: string;
    street?: string;
    postalCode?: string;
    country?: string;
    addressType?: AddressType;
    entityKey?: number;
    entityType?: string;
}

export class LookupDto implements ILookupDto {
    id?: number;
    name?: string;
    description?: string;
    lookupType?: string;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.lookupType = _data["lookupType"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["lookupType"] = this.lookupType;
        return data;
    }
}

export interface ILookupDto {
    id?: number;
    name?: string;
    description?: string;
    lookupType?: string;
}

export class AddLookupDto implements IAddLookupDto {
    id?: number;
    name?: string;
    description?: string;
    lookupTypeId?: number;

    constructor(data?: IAddLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.lookupTypeId = _data["lookupTypeId"];
        }
    }

    static fromJS(data: any): AddLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["lookupTypeId"] = this.lookupTypeId;
        return data;
    }
}

export interface IAddLookupDto {
    id?: number;
    name?: string;
    description?: string;
    lookupTypeId?: number;
}

export class AddLookupTypeDto implements IAddLookupTypeDto {
    id?: number;
    name?: string;
    description?: string;

    constructor(data?: IAddLookupTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AddLookupTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddLookupTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IAddLookupTypeDto {
    id?: number;
    name?: string;
    description?: string;
}

export class ApiResponseOfAddPersonDto implements IApiResponseOfAddPersonDto {
    data?: AddPersonDto | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfAddPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AddPersonDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfAddPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfAddPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfAddPersonDto {
    data?: AddPersonDto | undefined;
    message?: string;
    success?: boolean;
}

export class AddPersonDto implements IAddPersonDto {
    id?: number;
    firstName?: string;
    middleName?: string;
    lastName?: string;
    dateOfBirth?: Date;
    identityNumber?: string;
    genderId?: number | undefined;
    nationalityId?: number | undefined;
    titleId?: number | undefined;
    maritalStatusId?: number | undefined;
    occupationId?: number | undefined;
    identityTypeId?: number | undefined;
    raceId?: number | undefined;

    constructor(data?: IAddPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.identityNumber = _data["identityNumber"];
            this.genderId = _data["genderId"];
            this.nationalityId = _data["nationalityId"];
            this.titleId = _data["titleId"];
            this.maritalStatusId = _data["maritalStatusId"];
            this.occupationId = _data["occupationId"];
            this.identityTypeId = _data["identityTypeId"];
            this.raceId = _data["raceId"];
        }
    }

    static fromJS(data: any): AddPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["identityNumber"] = this.identityNumber;
        data["genderId"] = this.genderId;
        data["nationalityId"] = this.nationalityId;
        data["titleId"] = this.titleId;
        data["maritalStatusId"] = this.maritalStatusId;
        data["occupationId"] = this.occupationId;
        data["identityTypeId"] = this.identityTypeId;
        data["raceId"] = this.raceId;
        return data;
    }
}

export interface IAddPersonDto {
    id?: number;
    firstName?: string;
    middleName?: string;
    lastName?: string;
    dateOfBirth?: Date;
    identityNumber?: string;
    genderId?: number | undefined;
    nationalityId?: number | undefined;
    titleId?: number | undefined;
    maritalStatusId?: number | undefined;
    occupationId?: number | undefined;
    identityTypeId?: number | undefined;
    raceId?: number | undefined;
}

export class GetPersonDto implements IGetPersonDto {
    id?: number;
    firstName?: string;
    middleName?: string;
    lastName?: string;
    dateOfBirth?: Date;
    identityNumber?: string;
    gender?: string;
    nationality?: string;
    title?: string;
    maritalStatus?: string;
    occupation?: string;
    identityType?: string;
    race?: string;
    genderId?: number | undefined;
    nationalityId?: number | undefined;
    titleId?: number | undefined;
    maritalStatusId?: number | undefined;
    occupationId?: number | undefined;
    identityTypeId?: number | undefined;
    raceId?: number | undefined;
    isSelected?: boolean;

    constructor(data?: IGetPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.identityNumber = _data["identityNumber"];
            this.gender = _data["gender"];
            this.nationality = _data["nationality"];
            this.title = _data["title"];
            this.maritalStatus = _data["maritalStatus"];
            this.occupation = _data["occupation"];
            this.identityType = _data["identityType"];
            this.race = _data["race"];
            this.genderId = _data["genderId"];
            this.nationalityId = _data["nationalityId"];
            this.titleId = _data["titleId"];
            this.maritalStatusId = _data["maritalStatusId"];
            this.occupationId = _data["occupationId"];
            this.identityTypeId = _data["identityTypeId"];
            this.raceId = _data["raceId"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): GetPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["identityNumber"] = this.identityNumber;
        data["gender"] = this.gender;
        data["nationality"] = this.nationality;
        data["title"] = this.title;
        data["maritalStatus"] = this.maritalStatus;
        data["occupation"] = this.occupation;
        data["identityType"] = this.identityType;
        data["race"] = this.race;
        data["genderId"] = this.genderId;
        data["nationalityId"] = this.nationalityId;
        data["titleId"] = this.titleId;
        data["maritalStatusId"] = this.maritalStatusId;
        data["occupationId"] = this.occupationId;
        data["identityTypeId"] = this.identityTypeId;
        data["raceId"] = this.raceId;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IGetPersonDto {
    id?: number;
    firstName?: string;
    middleName?: string;
    lastName?: string;
    dateOfBirth?: Date;
    identityNumber?: string;
    gender?: string;
    nationality?: string;
    title?: string;
    maritalStatus?: string;
    occupation?: string;
    identityType?: string;
    race?: string;
    genderId?: number | undefined;
    nationalityId?: number | undefined;
    titleId?: number | undefined;
    maritalStatusId?: number | undefined;
    occupationId?: number | undefined;
    identityTypeId?: number | undefined;
    raceId?: number | undefined;
    isSelected?: boolean;
}

export class SearchPeopleQuery implements ISearchPeopleQuery {
    searchTerm?: string;

    constructor(data?: ISearchPeopleQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchTerm = _data["searchTerm"];
        }
    }

    static fromJS(data: any): SearchPeopleQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SearchPeopleQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchTerm"] = this.searchTerm;
        return data;
    }
}

export interface ISearchPeopleQuery {
    searchTerm?: string;
}

export class ApiResponseOfListOfQuotationViewDto implements IApiResponseOfListOfQuotationViewDto {
    data?: QuotationViewDto[] | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfListOfQuotationViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(QuotationViewDto.fromJS(item));
            }
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfListOfQuotationViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfListOfQuotationViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfListOfQuotationViewDto {
    data?: QuotationViewDto[] | undefined;
    message?: string;
    success?: boolean;
}

export class QuotationViewDto implements IQuotationViewDto {
    coverName?: string;
    coverId?: number;
    coverBasePremium?: number;
    finalPremium?: number;
    addOnsTotal?: number;
    calcNotes?: string;
    addOns?: QuotationAddOnDto[];

    constructor(data?: IQuotationViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coverName = _data["coverName"];
            this.coverId = _data["coverId"];
            this.coverBasePremium = _data["coverBasePremium"];
            this.finalPremium = _data["finalPremium"];
            this.addOnsTotal = _data["addOnsTotal"];
            this.calcNotes = _data["calcNotes"];
            if (Array.isArray(_data["addOns"])) {
                this.addOns = [] as any;
                for (let item of _data["addOns"])
                    this.addOns!.push(QuotationAddOnDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuotationViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coverName"] = this.coverName;
        data["coverId"] = this.coverId;
        data["coverBasePremium"] = this.coverBasePremium;
        data["finalPremium"] = this.finalPremium;
        data["addOnsTotal"] = this.addOnsTotal;
        data["calcNotes"] = this.calcNotes;
        if (Array.isArray(this.addOns)) {
            data["addOns"] = [];
            for (let item of this.addOns)
                data["addOns"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IQuotationViewDto {
    coverName?: string;
    coverId?: number;
    coverBasePremium?: number;
    finalPremium?: number;
    addOnsTotal?: number;
    calcNotes?: string;
    addOns?: QuotationAddOnDto[];
}

export class QuotationAddOnDto implements IQuotationAddOnDto {
    id?: number;
    name?: string;
    rate?: number;
    amount?: number;
    quotationId?: number;
    excess?: number;
    isSupported?: boolean;
    note?: string;
    changedAmount?: number;

    constructor(data?: IQuotationAddOnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rate = _data["rate"];
            this.amount = _data["amount"];
            this.quotationId = _data["quotationId"];
            this.excess = _data["excess"];
            this.isSupported = _data["isSupported"];
            this.note = _data["note"];
            this.changedAmount = _data["changedAmount"];
        }
    }

    static fromJS(data: any): QuotationAddOnDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationAddOnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["amount"] = this.amount;
        data["quotationId"] = this.quotationId;
        data["excess"] = this.excess;
        data["isSupported"] = this.isSupported;
        data["note"] = this.note;
        data["changedAmount"] = this.changedAmount;
        return data;
    }
}

export interface IQuotationAddOnDto {
    id?: number;
    name?: string;
    rate?: number;
    amount?: number;
    quotationId?: number;
    excess?: number;
    isSupported?: boolean;
    note?: string;
    changedAmount?: number;
}

export class GetQuotationChoiceDto implements IGetQuotationChoiceDto {
    sumInsured?: number | undefined;
    sumAssured?: number | undefined;
    insurableValue?: number | undefined;
    expectedMedicalCost?: number | undefined;
    riskLoading?: number | undefined;
    insuranceType?: string;
    insuranceTypeId?: number;
    excess?: number | undefined;
    fields?: QuotationFieldDto[];
    addOns?: QuotationAddOnDto[];

    constructor(data?: IGetQuotationChoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sumInsured = _data["sumInsured"];
            this.sumAssured = _data["sumAssured"];
            this.insurableValue = _data["insurableValue"];
            this.expectedMedicalCost = _data["expectedMedicalCost"];
            this.riskLoading = _data["riskLoading"];
            this.insuranceType = _data["insuranceType"];
            this.insuranceTypeId = _data["insuranceTypeId"];
            this.excess = _data["excess"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(QuotationFieldDto.fromJS(item));
            }
            if (Array.isArray(_data["addOns"])) {
                this.addOns = [] as any;
                for (let item of _data["addOns"])
                    this.addOns!.push(QuotationAddOnDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetQuotationChoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationChoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sumInsured"] = this.sumInsured;
        data["sumAssured"] = this.sumAssured;
        data["insurableValue"] = this.insurableValue;
        data["expectedMedicalCost"] = this.expectedMedicalCost;
        data["riskLoading"] = this.riskLoading;
        data["insuranceType"] = this.insuranceType;
        data["insuranceTypeId"] = this.insuranceTypeId;
        data["excess"] = this.excess;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.addOns)) {
            data["addOns"] = [];
            for (let item of this.addOns)
                data["addOns"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IGetQuotationChoiceDto {
    sumInsured?: number | undefined;
    sumAssured?: number | undefined;
    insurableValue?: number | undefined;
    expectedMedicalCost?: number | undefined;
    riskLoading?: number | undefined;
    insuranceType?: string;
    insuranceTypeId?: number;
    excess?: number | undefined;
    fields?: QuotationFieldDto[];
    addOns?: QuotationAddOnDto[];
}

export class QuotationFieldDto implements IQuotationFieldDto {
    id?: number;
    quotationId?: number;
    fieldValue?: string;
    coverStructureFieldId?: number;
    name?: string;
    type?: string;
    rules?: string;
    subHeading?: string;

    constructor(data?: IQuotationFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quotationId = _data["quotationId"];
            this.fieldValue = _data["fieldValue"];
            this.coverStructureFieldId = _data["coverStructureFieldId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.rules = _data["rules"];
            this.subHeading = _data["subHeading"];
        }
    }

    static fromJS(data: any): QuotationFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quotationId"] = this.quotationId;
        data["fieldValue"] = this.fieldValue;
        data["coverStructureFieldId"] = this.coverStructureFieldId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["rules"] = this.rules;
        data["subHeading"] = this.subHeading;
        return data;
    }
}

export interface IQuotationFieldDto {
    id?: number;
    quotationId?: number;
    fieldValue?: string;
    coverStructureFieldId?: number;
    name?: string;
    type?: string;
    rules?: string;
    subHeading?: string;
}

export class QuotationListDto implements IQuotationListDto {
    id?: number;
    coverName?: string;
    underwriterName?: string;
    finalPremium?: number;
    qouteNumber?: string;
    amountInsured?: number;
    excess?: number;
    personName?: string;
    createdBy?: string | undefined;
    maybeModifiedOn?: Date;

    constructor(data?: IQuotationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coverName = _data["coverName"];
            this.underwriterName = _data["underwriterName"];
            this.finalPremium = _data["finalPremium"];
            this.qouteNumber = _data["qouteNumber"];
            this.amountInsured = _data["amountInsured"];
            this.excess = _data["excess"];
            this.personName = _data["personName"];
            this.createdBy = _data["createdBy"];
            this.maybeModifiedOn = _data["maybeModifiedOn"] ? new Date(_data["maybeModifiedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): QuotationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coverName"] = this.coverName;
        data["underwriterName"] = this.underwriterName;
        data["finalPremium"] = this.finalPremium;
        data["qouteNumber"] = this.qouteNumber;
        data["amountInsured"] = this.amountInsured;
        data["excess"] = this.excess;
        data["personName"] = this.personName;
        data["createdBy"] = this.createdBy;
        data["maybeModifiedOn"] = this.maybeModifiedOn ? this.maybeModifiedOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IQuotationListDto {
    id?: number;
    coverName?: string;
    underwriterName?: string;
    finalPremium?: number;
    qouteNumber?: string;
    amountInsured?: number;
    excess?: number;
    personName?: string;
    createdBy?: string | undefined;
    maybeModifiedOn?: Date;
}

export class FieldsViewDto implements IFieldsViewDto {
    categorisedFields?: FieldCategory[];
    options?: FieldOptionDto[];

    constructor(data?: IFieldsViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categorisedFields"])) {
                this.categorisedFields = [] as any;
                for (let item of _data["categorisedFields"])
                    this.categorisedFields!.push(FieldCategory.fromJS(item));
            }
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(FieldOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldsViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldsViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categorisedFields)) {
            data["categorisedFields"] = [];
            for (let item of this.categorisedFields)
                data["categorisedFields"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IFieldsViewDto {
    categorisedFields?: FieldCategory[];
    options?: FieldOptionDto[];
}

export class FieldCategory implements IFieldCategory {
    name?: string;
    fields?: CoverStructureFieldDto[];

    constructor(data?: IFieldCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(CoverStructureFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldCategory {
        data = typeof data === 'object' ? data : {};
        let result = new FieldCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IFieldCategory {
    name?: string;
    fields?: CoverStructureFieldDto[];
}

export class FieldOptionDto implements IFieldOptionDto {
    lookupType?: string;
    values?: string[];

    constructor(data?: IFieldOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookupType = _data["lookupType"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): FieldOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookupType"] = this.lookupType;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IFieldOptionDto {
    lookupType?: string;
    values?: string[];
}

export class ApiResponseOfCreateQuotationRespDto implements IApiResponseOfCreateQuotationRespDto {
    data?: CreateQuotationRespDto | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfCreateQuotationRespDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CreateQuotationRespDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfCreateQuotationRespDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfCreateQuotationRespDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfCreateQuotationRespDto {
    data?: CreateQuotationRespDto | undefined;
    message?: string;
    success?: boolean;
}

export class CreateQuotationRespDto implements ICreateQuotationRespDto {
    conflictingQuoteId?: number;
    conflictingQuoteNumber?: string | undefined;
    conflictingCreatedBy?: string | undefined;
    matchingFieldDtos?: MatchingFieldDto[];
    quotationNumber?: string | undefined;
    quotationId?: number | undefined;

    constructor(data?: ICreateQuotationRespDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conflictingQuoteId = _data["conflictingQuoteId"];
            this.conflictingQuoteNumber = _data["conflictingQuoteNumber"];
            this.conflictingCreatedBy = _data["conflictingCreatedBy"];
            if (Array.isArray(_data["matchingFieldDtos"])) {
                this.matchingFieldDtos = [] as any;
                for (let item of _data["matchingFieldDtos"])
                    this.matchingFieldDtos!.push(MatchingFieldDto.fromJS(item));
            }
            this.quotationNumber = _data["quotationNumber"];
            this.quotationId = _data["quotationId"];
        }
    }

    static fromJS(data: any): CreateQuotationRespDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuotationRespDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conflictingQuoteId"] = this.conflictingQuoteId;
        data["conflictingQuoteNumber"] = this.conflictingQuoteNumber;
        data["conflictingCreatedBy"] = this.conflictingCreatedBy;
        if (Array.isArray(this.matchingFieldDtos)) {
            data["matchingFieldDtos"] = [];
            for (let item of this.matchingFieldDtos)
                data["matchingFieldDtos"].push(item ? item.toJSON() : <any>undefined);
        }
        data["quotationNumber"] = this.quotationNumber;
        data["quotationId"] = this.quotationId;
        return data;
    }
}

export interface ICreateQuotationRespDto {
    conflictingQuoteId?: number;
    conflictingQuoteNumber?: string | undefined;
    conflictingCreatedBy?: string | undefined;
    matchingFieldDtos?: MatchingFieldDto[];
    quotationNumber?: string | undefined;
    quotationId?: number | undefined;
}

export class MatchingFieldDto implements IMatchingFieldDto {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IMatchingFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MatchingFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchingFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IMatchingFieldDto {
    name?: string | undefined;
    value?: string | undefined;
}

export class SaveQuotationCommand implements ISaveQuotationCommand {
    quoteVariables?: GetQuotationChoiceDto;
    quote?: QuotationViewDto;
    personId?: number;
    isContinueingWithConflict?: boolean;

    constructor(data?: ISaveQuotationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quoteVariables = _data["quoteVariables"] ? GetQuotationChoiceDto.fromJS(_data["quoteVariables"]) : <any>undefined;
            this.quote = _data["quote"] ? QuotationViewDto.fromJS(_data["quote"]) : <any>undefined;
            this.personId = _data["personId"];
            this.isContinueingWithConflict = _data["isContinueingWithConflict"];
        }
    }

    static fromJS(data: any): SaveQuotationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaveQuotationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quoteVariables"] = this.quoteVariables ? this.quoteVariables.toJSON() : <any>undefined;
        data["quote"] = this.quote ? this.quote.toJSON() : <any>undefined;
        data["personId"] = this.personId;
        data["isContinueingWithConflict"] = this.isContinueingWithConflict;
        return data;
    }
}

export interface ISaveQuotationCommand {
    quoteVariables?: GetQuotationChoiceDto;
    quote?: QuotationViewDto;
    personId?: number;
    isContinueingWithConflict?: boolean;
}

export class ApiResponseOfCoverStructureFieldRuleDto implements IApiResponseOfCoverStructureFieldRuleDto {
    data?: CoverStructureFieldRuleDto | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfCoverStructureFieldRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CoverStructureFieldRuleDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfCoverStructureFieldRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfCoverStructureFieldRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfCoverStructureFieldRuleDto {
    data?: CoverStructureFieldRuleDto | undefined;
    message?: string;
    success?: boolean;
}

export class OverrideFieldRuleCommand implements IOverrideFieldRuleCommand {
    id?: number;
    quotationFieldId?: number;
    adjustmentType?: string;
    adjuster?: string;
    coverStructureFieldRuleId?: number;
    isAddingOverride?: boolean;
    overrideRuleId?: number;

    constructor(data?: IOverrideFieldRuleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quotationFieldId = _data["quotationFieldId"];
            this.adjustmentType = _data["adjustmentType"];
            this.adjuster = _data["adjuster"];
            this.coverStructureFieldRuleId = _data["coverStructureFieldRuleId"];
            this.isAddingOverride = _data["isAddingOverride"];
            this.overrideRuleId = _data["overrideRuleId"];
        }
    }

    static fromJS(data: any): OverrideFieldRuleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OverrideFieldRuleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quotationFieldId"] = this.quotationFieldId;
        data["adjustmentType"] = this.adjustmentType;
        data["adjuster"] = this.adjuster;
        data["coverStructureFieldRuleId"] = this.coverStructureFieldRuleId;
        data["isAddingOverride"] = this.isAddingOverride;
        data["overrideRuleId"] = this.overrideRuleId;
        return data;
    }
}

export interface IOverrideFieldRuleCommand {
    id?: number;
    quotationFieldId?: number;
    adjustmentType?: string;
    adjuster?: string;
    coverStructureFieldRuleId?: number;
    isAddingOverride?: boolean;
    overrideRuleId?: number;
}

export class GetQuotationDto implements IGetQuotationDto {
    id?: number;
    coverStructureId?: number;
    initialBasePremiumAtPurchase?: number;
    finalPremium?: number;
    adjustmentDescription?: string;
    qouteNumber?: string;
    amountInsured?: number;
    quoteNotes?: string;
    basePremiumAjustmentNotes?: string;
    personId?: number;
    coverStructure?: GetCoverDto;
    underwriter?: UnderwriterDto;
    underwriterInsurance?: UnderwriterInsViewDto;
    person?: GetPersonDto;
    quotationAddOns?: QuotationAddOnDto[];
    quotationFields?: QuotationFieldDto[];
    fieldsView?: FieldsViewDto;

    constructor(data?: IGetQuotationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coverStructureId = _data["coverStructureId"];
            this.initialBasePremiumAtPurchase = _data["initialBasePremiumAtPurchase"];
            this.finalPremium = _data["finalPremium"];
            this.adjustmentDescription = _data["adjustmentDescription"];
            this.qouteNumber = _data["qouteNumber"];
            this.amountInsured = _data["amountInsured"];
            this.quoteNotes = _data["quoteNotes"];
            this.basePremiumAjustmentNotes = _data["basePremiumAjustmentNotes"];
            this.personId = _data["personId"];
            this.coverStructure = _data["coverStructure"] ? GetCoverDto.fromJS(_data["coverStructure"]) : <any>undefined;
            this.underwriter = _data["underwriter"] ? UnderwriterDto.fromJS(_data["underwriter"]) : <any>undefined;
            this.underwriterInsurance = _data["underwriterInsurance"] ? UnderwriterInsViewDto.fromJS(_data["underwriterInsurance"]) : <any>undefined;
            this.person = _data["person"] ? GetPersonDto.fromJS(_data["person"]) : <any>undefined;
            if (Array.isArray(_data["quotationAddOns"])) {
                this.quotationAddOns = [] as any;
                for (let item of _data["quotationAddOns"])
                    this.quotationAddOns!.push(QuotationAddOnDto.fromJS(item));
            }
            if (Array.isArray(_data["quotationFields"])) {
                this.quotationFields = [] as any;
                for (let item of _data["quotationFields"])
                    this.quotationFields!.push(QuotationFieldDto.fromJS(item));
            }
            this.fieldsView = _data["fieldsView"] ? FieldsViewDto.fromJS(_data["fieldsView"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetQuotationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coverStructureId"] = this.coverStructureId;
        data["initialBasePremiumAtPurchase"] = this.initialBasePremiumAtPurchase;
        data["finalPremium"] = this.finalPremium;
        data["adjustmentDescription"] = this.adjustmentDescription;
        data["qouteNumber"] = this.qouteNumber;
        data["amountInsured"] = this.amountInsured;
        data["quoteNotes"] = this.quoteNotes;
        data["basePremiumAjustmentNotes"] = this.basePremiumAjustmentNotes;
        data["personId"] = this.personId;
        data["coverStructure"] = this.coverStructure ? this.coverStructure.toJSON() : <any>undefined;
        data["underwriter"] = this.underwriter ? this.underwriter.toJSON() : <any>undefined;
        data["underwriterInsurance"] = this.underwriterInsurance ? this.underwriterInsurance.toJSON() : <any>undefined;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        if (Array.isArray(this.quotationAddOns)) {
            data["quotationAddOns"] = [];
            for (let item of this.quotationAddOns)
                data["quotationAddOns"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.quotationFields)) {
            data["quotationFields"] = [];
            for (let item of this.quotationFields)
                data["quotationFields"].push(item ? item.toJSON() : <any>undefined);
        }
        data["fieldsView"] = this.fieldsView ? this.fieldsView.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetQuotationDto {
    id?: number;
    coverStructureId?: number;
    initialBasePremiumAtPurchase?: number;
    finalPremium?: number;
    adjustmentDescription?: string;
    qouteNumber?: string;
    amountInsured?: number;
    quoteNotes?: string;
    basePremiumAjustmentNotes?: string;
    personId?: number;
    coverStructure?: GetCoverDto;
    underwriter?: UnderwriterDto;
    underwriterInsurance?: UnderwriterInsViewDto;
    person?: GetPersonDto;
    quotationAddOns?: QuotationAddOnDto[];
    quotationFields?: QuotationFieldDto[];
    fieldsView?: FieldsViewDto;
}

export class GetCoverDto implements IGetCoverDto {
    id?: number;
    name?: string;
    rate?: number;
    description?: string;
    hasDependances?: boolean;
    hasBeneficiary?: boolean;
    underwriterId?: number;
    insuranceMainTypeId?: number;
    undewriterInsurance?: AddUnderwriterInsDto;
    underwriter?: UnderwriterDto;
    coverStructureFields?: CoverStructureFieldDto[];

    constructor(data?: IGetCoverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rate = _data["rate"];
            this.description = _data["description"];
            this.hasDependances = _data["hasDependances"];
            this.hasBeneficiary = _data["hasBeneficiary"];
            this.underwriterId = _data["underwriterId"];
            this.insuranceMainTypeId = _data["insuranceMainTypeId"];
            this.undewriterInsurance = _data["undewriterInsurance"] ? AddUnderwriterInsDto.fromJS(_data["undewriterInsurance"]) : <any>undefined;
            this.underwriter = _data["underwriter"] ? UnderwriterDto.fromJS(_data["underwriter"]) : <any>undefined;
            if (Array.isArray(_data["coverStructureFields"])) {
                this.coverStructureFields = [] as any;
                for (let item of _data["coverStructureFields"])
                    this.coverStructureFields!.push(CoverStructureFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCoverDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCoverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["description"] = this.description;
        data["hasDependances"] = this.hasDependances;
        data["hasBeneficiary"] = this.hasBeneficiary;
        data["underwriterId"] = this.underwriterId;
        data["insuranceMainTypeId"] = this.insuranceMainTypeId;
        data["undewriterInsurance"] = this.undewriterInsurance ? this.undewriterInsurance.toJSON() : <any>undefined;
        data["underwriter"] = this.underwriter ? this.underwriter.toJSON() : <any>undefined;
        if (Array.isArray(this.coverStructureFields)) {
            data["coverStructureFields"] = [];
            for (let item of this.coverStructureFields)
                data["coverStructureFields"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IGetCoverDto {
    id?: number;
    name?: string;
    rate?: number;
    description?: string;
    hasDependances?: boolean;
    hasBeneficiary?: boolean;
    underwriterId?: number;
    insuranceMainTypeId?: number;
    undewriterInsurance?: AddUnderwriterInsDto;
    underwriter?: UnderwriterDto;
    coverStructureFields?: CoverStructureFieldDto[];
}

export class AddUnderwriterInsDto implements IAddUnderwriterInsDto {
    id?: number;
    totalCommission?: number;
    commission?: number;
    vat?: number;
    underwriterId?: number;
    insuranceMainTypeId?: number;

    constructor(data?: IAddUnderwriterInsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.totalCommission = _data["totalCommission"];
            this.commission = _data["commission"];
            this.vat = _data["vat"];
            this.underwriterId = _data["underwriterId"];
            this.insuranceMainTypeId = _data["insuranceMainTypeId"];
        }
    }

    static fromJS(data: any): AddUnderwriterInsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddUnderwriterInsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalCommission"] = this.totalCommission;
        data["commission"] = this.commission;
        data["vat"] = this.vat;
        data["underwriterId"] = this.underwriterId;
        data["insuranceMainTypeId"] = this.insuranceMainTypeId;
        return data;
    }
}

export interface IAddUnderwriterInsDto {
    id?: number;
    totalCommission?: number;
    commission?: number;
    vat?: number;
    underwriterId?: number;
    insuranceMainTypeId?: number;
}

export class UnderwriterDto implements IUnderwriterDto {
    id?: number;
    name?: string;
    status?: UnderwriterStatus;

    constructor(data?: IUnderwriterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UnderwriterDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnderwriterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["status"] = this.status;
        return data;
    }
}

export interface IUnderwriterDto {
    id?: number;
    name?: string;
    status?: UnderwriterStatus;
}

export class UnderwriterInsViewDto implements IUnderwriterInsViewDto {
    id?: number;
    totalCommission?: number;
    commission?: number;
    vat?: number;
    underwriterId?: number;
    insuranceMainTypeId?: number;
    insuranceMainType?: string;

    constructor(data?: IUnderwriterInsViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.totalCommission = _data["totalCommission"];
            this.commission = _data["commission"];
            this.vat = _data["vat"];
            this.underwriterId = _data["underwriterId"];
            this.insuranceMainTypeId = _data["insuranceMainTypeId"];
            this.insuranceMainType = _data["insuranceMainType"];
        }
    }

    static fromJS(data: any): UnderwriterInsViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnderwriterInsViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalCommission"] = this.totalCommission;
        data["commission"] = this.commission;
        data["vat"] = this.vat;
        data["underwriterId"] = this.underwriterId;
        data["insuranceMainTypeId"] = this.insuranceMainTypeId;
        data["insuranceMainType"] = this.insuranceMainType;
        return data;
    }
}

export interface IUnderwriterInsViewDto {
    id?: number;
    totalCommission?: number;
    commission?: number;
    vat?: number;
    underwriterId?: number;
    insuranceMainTypeId?: number;
    insuranceMainType?: string;
}

export class ApiResponseOfBoolean implements IApiResponseOfBoolean {
    data?: boolean;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfBoolean {
    data?: boolean;
    message?: string;
    success?: boolean;
}

export class AddStateDto implements IAddStateDto {
    id?: number;
    name?: string;
    order?: number;
    isActiveState?: boolean;
    isFinalState?: boolean;
    isInitialState?: boolean;
    coverStructureId?: number;
    stateCategory?: string;
    requireUnderwriterApprovals?: boolean;
    isActive?: boolean;
    userIds?: string[];

    constructor(data?: IAddStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.isActiveState = _data["isActiveState"];
            this.isFinalState = _data["isFinalState"];
            this.isInitialState = _data["isInitialState"];
            this.coverStructureId = _data["coverStructureId"];
            this.stateCategory = _data["stateCategory"];
            this.requireUnderwriterApprovals = _data["requireUnderwriterApprovals"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AddStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["isActiveState"] = this.isActiveState;
        data["isFinalState"] = this.isFinalState;
        data["isInitialState"] = this.isInitialState;
        data["coverStructureId"] = this.coverStructureId;
        data["stateCategory"] = this.stateCategory;
        data["requireUnderwriterApprovals"] = this.requireUnderwriterApprovals;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface IAddStateDto {
    id?: number;
    name?: string;
    order?: number;
    isActiveState?: boolean;
    isFinalState?: boolean;
    isInitialState?: boolean;
    coverStructureId?: number;
    stateCategory?: string;
    requireUnderwriterApprovals?: boolean;
    isActive?: boolean;
    userIds?: string[];
}

export class GetStateDto implements IGetStateDto {
    id?: number;
    name?: string;
    order?: number;
    isActiveState?: boolean;
    isFinalState?: boolean;
    isInitialState?: boolean;
    coverStructureId?: number;
    requireUnderwriterApprovals?: boolean;
    stateCategory?: string;
    users?: GetStateUserDto[];
    isActive?: boolean;

    constructor(data?: IGetStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.isActiveState = _data["isActiveState"];
            this.isFinalState = _data["isFinalState"];
            this.isInitialState = _data["isInitialState"];
            this.coverStructureId = _data["coverStructureId"];
            this.requireUnderwriterApprovals = _data["requireUnderwriterApprovals"];
            this.stateCategory = _data["stateCategory"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(GetStateUserDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): GetStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["isActiveState"] = this.isActiveState;
        data["isFinalState"] = this.isFinalState;
        data["isInitialState"] = this.isInitialState;
        data["coverStructureId"] = this.coverStructureId;
        data["requireUnderwriterApprovals"] = this.requireUnderwriterApprovals;
        data["stateCategory"] = this.stateCategory;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item ? item.toJSON() : <any>undefined);
        }
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IGetStateDto {
    id?: number;
    name?: string;
    order?: number;
    isActiveState?: boolean;
    isFinalState?: boolean;
    isInitialState?: boolean;
    coverStructureId?: number;
    requireUnderwriterApprovals?: boolean;
    stateCategory?: string;
    users?: GetStateUserDto[];
    isActive?: boolean;
}

export class GetStateUserDto implements IGetStateUserDto {
    id?: number;
    userId?: string;
    stateId?: number;
    stateName?: string;
    userName?: string;

    constructor(data?: IGetStateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.stateId = _data["stateId"];
            this.stateName = _data["stateName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): GetStateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IGetStateUserDto {
    id?: number;
    userId?: string;
    stateId?: number;
    stateName?: string;
    userName?: string;
}

export class AddInuranceDefaultFieldDto implements IAddInuranceDefaultFieldDto {
    id?: number;
    name?: string;
    type?: string;
    hint?: string;
    isRequired?: boolean;
    isActive?: boolean;
    defaultValue?: string;
    subHeading?: string;
    validationPattern?: string | undefined;
    order?: number;
    insuranceMainTypeId?: number;
    validationObject?: string | undefined;

    constructor(data?: IAddInuranceDefaultFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.hint = _data["hint"];
            this.isRequired = _data["isRequired"];
            this.isActive = _data["isActive"];
            this.defaultValue = _data["defaultValue"];
            this.subHeading = _data["subHeading"];
            this.validationPattern = _data["validationPattern"];
            this.order = _data["order"];
            this.insuranceMainTypeId = _data["insuranceMainTypeId"];
            this.validationObject = _data["validationObject"];
        }
    }

    static fromJS(data: any): AddInuranceDefaultFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddInuranceDefaultFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["hint"] = this.hint;
        data["isRequired"] = this.isRequired;
        data["isActive"] = this.isActive;
        data["defaultValue"] = this.defaultValue;
        data["subHeading"] = this.subHeading;
        data["validationPattern"] = this.validationPattern;
        data["order"] = this.order;
        data["insuranceMainTypeId"] = this.insuranceMainTypeId;
        data["validationObject"] = this.validationObject;
        return data;
    }
}

export interface IAddInuranceDefaultFieldDto {
    id?: number;
    name?: string;
    type?: string;
    hint?: string;
    isRequired?: boolean;
    isActive?: boolean;
    defaultValue?: string;
    subHeading?: string;
    validationPattern?: string | undefined;
    order?: number;
    insuranceMainTypeId?: number;
    validationObject?: string | undefined;
}

export class UnderwriterViewDto implements IUnderwriterViewDto {
    id?: number;
    name?: string;
    status?: UnderwriterStatus;
    contact?: ContactViewDto[];
    address?: AddressViewDto[];

    constructor(data?: IUnderwriterViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.status = _data["status"];
            if (Array.isArray(_data["contact"])) {
                this.contact = [] as any;
                for (let item of _data["contact"])
                    this.contact!.push(ContactViewDto.fromJS(item));
            }
            if (Array.isArray(_data["address"])) {
                this.address = [] as any;
                for (let item of _data["address"])
                    this.address!.push(AddressViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UnderwriterViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnderwriterViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["status"] = this.status;
        if (Array.isArray(this.contact)) {
            data["contact"] = [];
            for (let item of this.contact)
                data["contact"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUnderwriterViewDto {
    id?: number;
    name?: string;
    status?: UnderwriterStatus;
    contact?: ContactViewDto[];
    address?: AddressViewDto[];
}

export class ApiResponseOfListOfUnderwriterInsViewDto implements IApiResponseOfListOfUnderwriterInsViewDto {
    data?: UnderwriterInsViewDto[] | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfListOfUnderwriterInsViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UnderwriterInsViewDto.fromJS(item));
            }
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfListOfUnderwriterInsViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfListOfUnderwriterInsViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : <any>undefined);
        }
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfListOfUnderwriterInsViewDto {
    data?: UnderwriterInsViewDto[] | undefined;
    message?: string;
    success?: boolean;
}

export class ApiResponseOfUnderwriterInsViewDto implements IApiResponseOfUnderwriterInsViewDto {
    data?: UnderwriterInsViewDto | undefined;
    message?: string;
    success?: boolean;

    constructor(data?: IApiResponseOfUnderwriterInsViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UnderwriterInsViewDto.fromJS(_data["data"]) : <any>undefined;
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ApiResponseOfUnderwriterInsViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponseOfUnderwriterInsViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IApiResponseOfUnderwriterInsViewDto {
    data?: UnderwriterInsViewDto | undefined;
    message?: string;
    success?: boolean;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}